<!DOCTYPE HTML>
<html>
<head>
	<title>Group Apollo</title>
	<link rel="stylesheet" type="text/css" href="./css/style.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
</head>

<body>
	<div id="logo"> 
	<h1>NODE.js demo</h1>
	</div>

	<div id="nav-bar">
	<p><a id="main" href="./index.html">Main</a>|<a id="presbtn" href="presentation.html">Presentation</a>|<a id="compbtn" href="./comparisons.html">Comparisons</a>|<a  id="tutbtn" href="./tutorial.html">Simple Tutorial</a>|<a id="demobtn" href="./demo.html">Demo</a>|<a id="aboutbtn" href="./about.html">About</a></p>
	</div>

	<div id="content">
	<h2>Why using Node.js?</h2>
	<p>Besides Node.js, there are many alternatives out there, such as PHP, Django(via Python), Ruby on Rails and Spring Tool Suite. You may ask why using Node.js instead of them?</p>
	<p>Below are some reasons:</p>
	<ul>
		<li>Take the advantages of the developer's familarities of JavaScript</li>
		<li>Little overhead by using the event-drive mechanism</li>
		<li>Simple but yet powerful</li>
		<li>More free style: free to customize your server</li>
		</p>
	</ul>


	<h2>Ruby on Rails & Node.js</h2>
        <table style="margin-left:25px">
                <tr>
                <td><strong>Ruby on Rails</strong></td>
                <td><img src="http://upload.wikimedia.org/wikipedia/en/thumb/e/e9/Ruby_on_Rails.svg/150px-Ruby_on_Rails.svg.png" alt="rails" width="100" height="75"></td>
                </tr>
</table>
        <p>&nbsp&nbspRuby on Rails, often shortened to Rails, is an open source full-stack web application framework for the Ruby programming language. Ruby on Rails runs on the general-purpose programming language Ruby, which predates it by more than a decade. Rails is a full-stack framework, meaning that it gives the web developer the ability to create pages and applications that gather information from the web server, talk to or query the database, and render templates out of the box. As a result, Rails features a routing system that is independent of the web server.</p>
        <table style="margin-left:25px">
                <tr><td><strong>Node.js</strong></td><td><img src="http://www.nodehispano.com/wp-content/uploads/node_js.jpeg" alt="n.js" width="100" height="75"></td></table>
        <ul>
        <li>Node.js is a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. </li>
        <li>Node.js is a server bundled with low-level routing and sysadmin capabilities and written to be utilized with Javascript.</li>
        <li>Programs written on the server side are using event-driven, asynchronous I/O to minimize overhead and maximize scalability, perfect for data-intensive real-time applications that run across distributed devices.</li>
        </ul>
        <p><strong>Node.js vs Ruby on Rails</strong></p>
        <ul><li>Node.js enables a front-to-back Javascript environment</li><li>Node.js is light and fast (google's V8 JS engine!)</li><li>As mentioned above, async-driven, parallel performing.</li>-----------------------------------------------------------
        <li>In Rails, you are forced to contend with SQL, Ruby, and Javascript.</li><li>Powerful engines for Views, Controllers and Models.</li><li>Database adapter for the majority of them, supporting plug your own.</li><li>Database migrations, so multiple dev can sync and experiment with their DB.</li>
        </ul>
        <p>There are many pros in Node.js and Ruby on Rails. So, when to use Node.js and when to use Rails?</p>
        <table style="margin-left:25px">
                <tr><td><strong>Node.js</strong></td><td><strong>Rails</strong></td></tr>
                <tr><td><ul><li>The database is complex in terms of associations.</li><li>The app structure is well defined.</li><li>Many developers in parallel keep the DB up-to-date with migrations</li></ul></td><td><ul><li>APIs</li><li>Real-time Web/mobile apps.</li><li>Application that should scale to lots of concurrent requests</li></td></tr>
                </table>
	<h2>Spring Tool Suite Framework</h2>			
	<p>&nbsp&nbspThe Spring Tool Suite Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications. A key element of Spring is its infrastructural support at the application level, meaning that Spring focuses on decoupling the web application through injecting values at run time. This allows teams to focus on application-level business logic, without having to worry about static specifications or other class implementations.</p>
	<p>&nbsp&nbspSpring Tool Suite allows a team of developers to perform dependency injection with XML and annotation-based configuration styles. Meaning that a team can create methods with parameters that are injected at run time, not on compile time. This gives the ability for someone who knows nothing of another class to create their class and only have to worry about injecting the proper values such that the web applications starts.  Advantage of having parameters being injected at run time is that another team (like SV&V or Engineering) can inject their own values via a configurations table. Ex: A datasource. Using Node.js this isn¡¯t the case. We wouldn¡¯t be able to use a configuration file to determine how certain classes need to be initiated at server start up.  </p>			
	<p>&nbsp&nbspSpring Tool Suite also allows for <em>declarative transactions, declarative caching, declarative validation, and declarative formatting.</em> A declarative transaction is where a annotated based web server can decided which transactions go to which Controllers all through the use of annotations. Once a Controller has been selected, we can validate a HTTP request before the Controller (from MVC model) starts work on the request. This type of declarative validation comes in the form of XML Schemas or XSD.
Once a Controller decides what to do with the request, we can use a memory cache (memchace) to retrieve common output values. As stated before, since Spring is annotation based a annotation can be used to reference a memechace. We can inject memcache size, timeout value and what values to cache all from a configuration file. ich testing facilities for unit tests as well as for integration tests. JUnit tests are easy to create. Since the MVC model is used within Spring, we can mock out various services within the web application to create effective unit tests.</p>	
	<p>&nbsp&nbsp<strong>Summary</strong></p>
	<p>&nbsp&nbspAs you can note Spring Tool Suite is used more for Enterprise web applications where multiple teams are involved in writing code. Since dependency injection is a big aspect of STS we do not have to rely on having to create a new build of our server if we want different values for certain parameters. All we would have to do is change the configuration file and restart the server.</p>
	
	<h2>Node.js vs Django & PHP:</h2>

<p>&nbsp&nbspBeside Node.js, there are many alternatives out there for the backend programming, among which, PHP is one of the most traditional choice, and Django is another one which has gained much popularity recent years. Why do we choose Node.js as our first choice when implementing backend? Below i will use PHP and Django as comparisons to show why Node.js won the match in our mind.</p>

<p><strong>1.To simplify web developers daily work and provide a steep learning curve</strong></p>
	
	<p>&nbsp&nbspNormally, when developers want to step into the field of web development, especially 
	dynamic web developments(involving database). Not only a developer need to learn the 
	front-end design, which means at least HTML, CSS and JavaScript, but also the backend
	programming. People may choose PHP or Python(if using Django) as the server-side 
            language. Regardless which one is chosen, most developers will find it easy to learn
            the front end design. In other word, they learn HTML, CSS and JavaScript without 
            problem. But when it comes to the backend, they may encounter problems, no matter
            being confused about the architecture or the needs of spending time to learn another 
           language(PHP or Python) to implement the server side structure.</p>

	<p>&nbsp&nbspNode.js solves the problem by taking the advantage of the fact that most web 
            developers are familiar with JavaScript. If a developer has a basic understanding of 
            JavaScript, he/she will easy to go the next step--backend design. By using Node.js,
            a developer will use same language and syntax for both frontend and backend, just doing
	different tasks£®There is no need to waste much more time to learn another language. In
	turn it provides a steep learning curve.</p>

<p><strong>2.multithreaded programing vs event-driven programing</strong></p>
	
	<ul><li><strong>Fact:</strong>traditional programming language does I/O the same way as it does local function</li>
	<li><strong>calls:</strong> processing cannot continue until an operation finishes.</li></ul>
	
	<p>&nbsp&nbspTo improves the user¡¯s experience, there are many solutions were invented, like
             multi-processes or multithreaded programming. The purpose is to isolate each users so
             that one user won¡¯t be influenced by another with a slow I/O operations. PHP and Django
	use multithreaded programming. It¡¯s better than multi-process. But sometime it doesn¡¯t
            scale well and will place a big burden on the processor when handling too many users.
	Also, it¡¯s not easy to learn multithreaded programming. A developer has to carefully deal
            with semaphores to decrease the risks of deadlocks.</p>




	<p>&nbsp&nbspNode.js uses JavaScript¡¯s event-driven mechanism which has a big advantage.
            Event-driven programming is a programming style whereby the flow of execution is
            determined by events. Events are handled by event handlers or event callbacks. An event
            callback is a function that is invoked when something significant happens ¡ª such as
when the result of a database query is available or when the user clicks on a button. This 
mechanism significantly decreases the overhead and ease the developers¡¯ work. </p>

<p><strong>3.More freestyle</strong></p>

<p>&nbsp&nbspBy using Django, a developer can use the the build-in http server the framework provides.
This ease the developer¡¯s work in some ways. However if the developer want to change
something or customize the server, he/her has to dive deeply to find the right places
and figure out how to do that. </p>

<p>&nbsp&nbspUsing Node.js, developers will build the full stack of the web applications by themselves,
but it¡¯s not hard. They freely created the http server, view logic or request handler as they
need. By building the web application, they are building the system at the same time.	</p>
	
	</div>	
</body>
</html>