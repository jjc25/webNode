<!DOCTYPE HTML>
<html>
<head>
	<title>Group Apollo</title>
	<link rel="stylesheet" type="text/css" href="./css/style.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
</head>

<body>
	<div id="logo"> 
	<h1>NODE.js demo</h1>
	</div>

	<div id="nav-bar">
	<p><a id="main" href="./index.html">Main</a>|<a id="presbtn" href="presentation.html">Presentation</a>|<a id="compbtn" href="./comparisons.html">Comparisons</a>|<a  id="tutbtn" href="./tutorial.html">Simple Tutorial</a>|<a id="demobtn" href="./demo.html">Demo</a>|<a id="aboutbtn" href="./about.html">About</a></p>
	</div>

	<div id="content">
	<h2>Why using Node.js?</h2>
	<p>Besides Node.js, there are many alternatives out there, such as PHP, Django(via Python), Ruby on Rails and Spring Tool Suite. You may ask why using Node.js instead of them?</p>
	<p>Below are some reasons:</p>
	<ul>
		<li>Take the advantages of the developer's familarities of JavaScript</li>
		<li>Little overhead by using the event-drive mechanism</li>
		<li>Simple but yet powerful</li>
		<li>More free style: free to customize your server</li>
		</p>
	</ul>


	<h2>Ruby on Rails & Node.js</h2>
        <table style="margin-left:25px">
                <tr>
                <td><strong>Ruby on Rails</strong></td>
                <td><img src="http://upload.wikimedia.org/wikipedia/en/thumb/e/e9/Ruby_on_Rails.svg/150px-Ruby_on_Rails.svg.png" alt="rails" width="100" height="75"></td>
                </tr>
</table>
        <p>&nbsp&nbspRuby on Rails, often shortened to Rails, is an open source full-stack web application framework for the Ruby programming language. Ruby on Rails runs on the general-purpose programming language Ruby, which predates it by more than a decade. Rails is a full-stack framework, meaning that it gives the web developer the ability to create pages and applications that gather information from the web server, talk to or query the database, and render templates out of the box. As a result, Rails features a routing system that is independent of the web server.</p>
        <table style="margin-left:25px">
                <tr><td><strong>Node.js</strong></td><td><img src="http://www.nodehispano.com/wp-content/uploads/node_js.jpeg" alt="n.js" width="100" height="75"></td></table>
        <ul>
        <li>Node.js is a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. </li>
        <li>Node.js is a server bundled with low-level routing and sysadmin capabilities and written to be utilized with Javascript.</li>
        <li>Programs written on the server side are using event-driven, asynchronous I/O to minimize overhead and maximize scalability, perfect for data-intensive real-time applications that run across distributed devices.</li>
        </ul>
        <p><strong>Node.js vs Ruby on Rails</strong></p>
        <ul><li>Node.js enables a front-to-back Javascript environment</li><li>Node.js is light and fast (google's V8 JS engine!)</li><li>As mentioned above, async-driven, parallel performing.</li>-----------------------------------------------------------
        <li>In Rails, you are forced to contend with SQL, Ruby, and Javascript.</li><li>Powerful engines for Views, Controllers and Models.</li><li>Database adapter for the majority of them, supporting plug your own.</li><li>Database migrations, so multiple dev can sync and experiment with their DB.</li>
        </ul>
        <p>There are many pros in Node.js and Ruby on Rails. So, when to use Node.js and when to use Rails?</p>
        <table style="margin-left:25px">
                <tr><td><strong>Node.js</strong></td><td><strong>Rails</strong></td></tr>
                <tr><td><ul><li>The database is complex in terms of associations.</li><li>The app structure is well defined.</li><li>Many developers in parallel keep the DB up-to-date with migrations</li></ul></td><td><ul><li>APIs</li><li>Real-time Web/mobile apps.</li><li>Application that should scale to lots of concurrent requests</li></td></tr>
                </table>
	<h2>Spring Tool Suite Framework</h2>			
	<p>&nbsp&nbspThe Spring Tool Suite Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications. A key element of Spring is its infrastructural support at the application level, meaning that Spring focuses on decoupling the web application through injecting values at run time. This allows teams to focus on application-level business logic, without having to worry about static specifications or other class implementations.</p>
	<p>&nbsp&nbspSpring Tool Suite allows a team of developers to perform dependency injection with XML and annotation-based configuration styles. Meaning that a team can create methods with parameters that are injected at run time, not on compile time. This gives the ability for someone who knows nothing of another class to create their class and only have to worry about injecting the proper values such that the web applications starts.  Advantage of having parameters being injected at run time is that another team (like SV&V or Engineering) can inject their own values via a configurations table. Ex: A datasource. Using Node.js this isn¡¯t the case. We wouldn¡¯t be able to use a configuration file to determine how certain classes need to be initiated at server start up.  </p>			
	<p>&nbsp&nbspSpring Tool Suite also allows for <em>declarative transactions, declarative caching, declarative validation, and declarative formatting.</em> A declarative transaction is where a annotated based web server can decided which transactions go to which Controllers all through the use of annotations. Once a Controller has been selected, we can validate a HTTP request before the Controller (from MVC model) starts work on the request. This type of declarative validation comes in the form of XML Schemas or XSD.
Once a Controller decides what to do with the request, we can use a memory cache (memchace) to retrieve common output values. As stated before, since Spring is annotation based a annotation can be used to reference a memechace. We can inject memcache size, timeout value and what values to cache all from a configuration file. ich testing facilities for unit tests as well as for integration tests. JUnit tests are easy to create. Since the MVC model is used within Spring, we can mock out various services within the web application to create effective unit tests.</p>	
	<p>&nbsp&nbsp<strong>Summary</strong></p>
	<p>&nbsp&nbspAs you can note Spring Tool Suite is used more for Enterprise web applications where multiple teams are involved in writing code. Since dependency injection is a big aspect of STS we do not have to rely on having to create a new build of our server if we want different values for certain parameters. All we would have to do is change the configuration file and restart the server.</p>
	</div>	
</body>
</html>